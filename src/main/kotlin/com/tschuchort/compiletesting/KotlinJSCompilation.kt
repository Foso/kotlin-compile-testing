package com.tschuchort.compiletesting

import io.github.classgraph.ClassGraph
import okio.Buffer
import org.jetbrains.kotlin.base.kapt3.KaptOptions
import org.jetbrains.kotlin.cli.common.arguments.K2JSCompilerArguments
import org.jetbrains.kotlin.cli.common.messages.MessageRenderer
import org.jetbrains.kotlin.cli.common.messages.PrintingMessageCollector
import org.jetbrains.kotlin.cli.js.K2JSCompiler
import org.jetbrains.kotlin.cli.jvm.plugins.ServiceLoaderLite
import org.jetbrains.kotlin.compiler.plugin.ComponentRegistrar
import org.jetbrains.kotlin.config.JVMAssertionsMode
import org.jetbrains.kotlin.config.JvmDefaultMode
import org.jetbrains.kotlin.config.JvmTarget
import org.jetbrains.kotlin.config.Services
import java.io.File
import java.io.OutputStream
import java.io.PrintStream
import java.net.URI
import java.nio.file.Files
import java.nio.file.Paths

/**
 * TODO: Remove kapt and everything that is not needed for KotlinJS Compilation
 *
* */
@Suppress("MemberVisibilityCanBePrivate")
class KotlinJSCompilation {
    /** Working directory for the compilation */
    var workingDir: File by default {
        val path = Files.createTempDirectory("Kotlin-Compilation")
        log("Created temporary working directory at ${path.toAbsolutePath()}")
        return@default path.toFile()
    }

    /** Arbitrary arguments to be passed to kapt */
    var kaptArgs: MutableMap<String, String> = mutableMapOf()

    /**
     * Paths to directories or .jar files that contain classes
     * to be made available in the compilation (i.e. added to
     * the classpath)
     */
    var classpaths: List<File> = emptyList()

    /** Source files to be compiled */
    var sources: List<SourceFile> = emptyList()

    /** Annotation processors to be passed to kapt */
    //var annotationProcessors: List<Processor> = emptyList()

    var componentRegistrars: List<ComponentRegistrar> = emptyList()

    /** Print verbose logging info */
    var verbose: Boolean = true

    /**
     * Helpful information (if [verbose] = true) and the compiler
     * system output will be written to this stream
     */
    var messageOutputStream: OutputStream = System.out

    /** Inherit classpath from calling process */
    var inheritClassPath: Boolean = false

    /** Include Kotlin runtime in to resulting .jar */
    var includeRuntime: Boolean = false

    /** Make kapt correct error types */
    var correctErrorTypes: Boolean = true

    /** Suppress all warnings */
    var suppressWarnings: Boolean = false

    /** All warnings should be treated as errors */
    var allWarningsAsErrors: Boolean = false

    /** Report locations of files generated by the compiler */
    var reportOutputFiles: Boolean by default { verbose }

    /** Report on performance of the compilation */
    var reportPerformance: Boolean = false

    /** Name of the generated .kotlin_module file */
    var moduleName: String? = null

    /** Target version of the generated JVM bytecode */
    var jvmTarget: String = JvmTarget.DEFAULT.description

    /** Generate metadata for Java 1.8 reflection on method parameters */
    var javaParameters: Boolean = false

    /** Use the IR backend */
    var useIR: Boolean = false



    /**
     * Root modules to resolve in addition to the initial modules,
     * or all modules on the module path if <module> is ALL-MODULE-PATH
     */
    var additionalJavaModules: MutableList<File> = mutableListOf()

    /** Don't generate not-null assertions for arguments of platform types */
    var noCallAssertions: Boolean = false

    /** Don't generate not-null assertion for extension receiver arguments of platform types */
    var noReceiverAssertions: Boolean = false

    /** Don't generate not-null assertions on parameters of methods accessible from Java */
    var noParamAssertions: Boolean = false

    /** Generate nullability assertions for non-null Java expressions */
    var strictJavaNullabilityAssertions: Boolean = false

    /** Disable optimizations */
    var noOptimize: Boolean = false

    /**
     * Normalize constructor calls (disable: don't normalize; enable: normalize),
     * default is 'disable' in language version 1.2 and below, 'enable' since language version 1.3
     *
     * {disable|enable}
     */
    var constructorCallNormalizationMode: String? = null

    /** Assert calls behaviour {always-enable|always-disable|jvm|legacy} */
    var assertionsMode: String? = JVMAssertionsMode.DEFAULT.description

    /** Path to the .xml build file to compile */
    var buildFile: File? = null

    /** Compile multifile classes as a hierarchy of parts and facade */
    var inheritMultifileParts: Boolean = false

    /** Use type table in metadata serialization */
    var useTypeTable: Boolean = false

    /** Allow Kotlin runtime libraries of incompatible versions in the classpath */
    var skipRuntimeVersionCheck: Boolean = false

    /** Path to JSON file to dump Java to Kotlin declaration mappings */
    var declarationsOutputPath: File? = null

    /** Combine modules for source files and binary dependencies into a single module */
    var singleModule: Boolean = false

    /** Suppress the \"cannot access built-in declaration\" error (useful with -no-stdlib) */
    var suppressMissingBuiltinsError: Boolean = false

    /** Script resolver environment in key-value pairs (the value could be quoted and escaped) */
    var scriptResolverEnvironment: MutableMap<String, String> = mutableMapOf()

    /** Java compiler arguments */
    var javacArguments: MutableList<String> = mutableListOf()

    /** Package prefix for Java files */
    var javaPackagePrefix: String? = null

    /**
     * Specify behavior for Checker Framework compatqual annotations (NullableDecl/NonNullDecl).
     * Default value is 'enable'
     */
    var supportCompatqualCheckerFrameworkAnnotations: String? = null

    /** Do not throw NPE on explicit 'equals' call for null receiver of platform boxed primitive type */
    var noExceptionOnExplicitEqualsForBoxedNull: Boolean = false

    /** Allow to use '@JvmDefault' annotation for JVM default method support.
     * {disable|enable|compatibility}
     * */
    var jvmDefault: String = JvmDefaultMode.DEFAULT.description

    /** Generate metadata with strict version semantics (see kdoc on Metadata.extraInt) */
    var strictMetadataVersionSemantics: Boolean = false

    /**
     * Transform '(' and ')' in method names to some other character sequence.
     * This mode can BREAK BINARY COMPATIBILITY and is only supposed to be used as a workaround
     * of an issue in the ASM bytecode framework. See KT-29475 for more details
     */
    var sanitizeParentheses: Boolean = false

    /** Paths to output directories for friend modules (whose internals should be visible) */
    var friendPaths: MutableList<File> = mutableListOf()

    /**
     * Path to the JDK to be used
     *
     * If null, no JDK will be used with kotlinc (option -no-jdk)
     * and the system java compiler will be used with empty bootclasspath
     * (on JDK8) or --system none (on JDK9+). This can be useful if all
     * the JDK classes you need are already on the (inherited) classpath.
     * */
    var jdkHome: File? by default { getJdkHome() }

    /**
     * Path to the kotlin-stdlib.jar
     * If none is given, it will be searched for in the host
     * process' classpaths
     */
    var kotlinJsStdLibJar: File? by default {
        findInHostClasspath(
            hostClasspaths, "kotlin-stdlib-js.jar",
            Regex("(kotlin-stdlib-js|kotlin-runtime)(-[0-9]+\\.[0-9]+\\.[0-9]+)\\.jar")
        )
    }


    // Directory for input source files
    private val sourcesDir get() = workingDir.resolve("sources")

    // *.class files, Jars and resources (non-temporary) that are created by the
    // compilation will land here
    val classesDir get() = workingDir.resolve("classes")

    // Base directory for kapt stuff
    private val kaptBaseDir get() = workingDir.resolve("kapt")

    // Java annotation processors that are compile by kapt will put their generated files here
    val kaptSourceDir get() = kaptBaseDir.resolve("sources")

    // Output directory for Kotlin source files generated by kapt
    val kaptKotlinGeneratedDir
        get() = kaptArgs[OPTION_KAPT_KOTLIN_GENERATED]
            ?.let { path ->
                require(File(path).isDirectory) { "$OPTION_KAPT_KOTLIN_GENERATED must be a directory" }
                File(path)
            }
            ?: File(kaptBaseDir, "kotlinGenerated")

    val kaptStubsDir get() = kaptBaseDir.resolve("stubs")
    val kaptIncrementalDataDir get() = kaptBaseDir.resolve("incrementalData")


    private fun getResourcesPath(): String {
        val resourceName = "META-INF/services/org.jetbrains.kotlin.compiler.plugin.ComponentRegistrar"
        return this::class.java.classLoader.getResources(resourceName)
            .asSequence()
            .mapNotNull { url ->
                val uri = URI.create(url.toString().removeSuffix("/$resourceName"))
                when (uri.scheme) {
                    "jar" -> Paths.get(URI.create(uri.schemeSpecificPart.removeSuffix("!")))
                    "file" -> Paths.get(uri)
                    else -> return@mapNotNull null
                }.toAbsolutePath()
            }
            .find { resourcesPath ->
                ServiceLoaderLite.findImplementations(ComponentRegistrar::class.java, listOf(resourcesPath.toFile()))
                    .any { implementation -> implementation == CommonComponentRegistrar::class.java.name }
            }?.toString() ?: throw AssertionError("Could not get path to ComponentRegistrar service from META-INF")
    }


    private fun compileKotlinJS(sourceFiles: List<File>): ExitCode {
        val sources = sourceFiles +
                kaptKotlinGeneratedDir.listFilesRecursively() +
                kaptSourceDir.listFilesRecursively()

        // if no Kotlin sources are available, skip the compileKotlin step
        if (sources.filter<File>(File::hasKotlinFileExtension).isEmpty())
            return ExitCode.OK

        // in this step also include source files generated by kapt in the previous step


        val compilerMessageCollector = PrintingMessageCollector(
            internalMessageStream, MessageRenderer.GRADLE_STYLE, verbose
        )

        val kotlinSources = sourceFiles.filter(File::hasKotlinFileExtension)
        val sourcePaths = mutableListOf<File>().apply {

            if (kotlinSources.isNotEmpty()) {
                addAll(kotlinSources)
            } else {
                /* __HACK__: The K2JVMCompiler expects at least one Kotlin source file or it will crash.
                   We still need kapt to run even if there are no Kotlin sources because it executes APs
                   on Java sources as well. Alternatively we could call the JavaCompiler instead of kapt
                   to do annotation processing when there are only Java sources, but that's quite a lot
                   of work (It can not be done in the compileJava step because annotation processors on
                   Java files might generate Kotlin files which then need to be compiled in the
                   compileKotlin step before the compileJava step). So instead we trick K2JVMCompiler
                   by just including an empty .kt-File. */
                add(SourceFile.new("emptyKotlinFile.kt", "").writeIfNeeded(kaptBaseDir))
            }
        }.map(File::getAbsolutePath).distinct()

        val jsArgs = K2JSCompilerArguments().also {
            // the compiler should never look for stdlib or reflect in the
            // kotlinHome directory (which is null anyway). We will put them
            // in the classpath manually if they're needed
            it.noStdlib = true
            it.freeArgs = sourcePaths
            it.sourceMap = true
            it.listPhases = true
            it.pluginClasspaths = (it.pluginClasspaths?.toList() ?: emptyList<String>() + getResourcesPath())
                .distinct().toTypedArray()
            it.moduleKind = "commonjs"
            it.outputFile= workingDir.absolutePath+"test.js"
            it.metaInfo = true
            it.sourceMapBaseDirs = commonClasspaths().joinToString(separator = File.pathSeparator)
            it.libraries = listOf(kotlinJsStdLibJar).joinToString(separator = ":")

            it.multiPlatform = true
            it.reportOutputFiles=true

        }


        CommonComponentRegistrar.threadLocalParameters.set(
            CommonComponentRegistrar.Parameters(
                emptyList(),
                componentRegistrars,
				KaptOptions.Builder()
            )
        )

        return convertKotlinExitCode(
            K2JSCompiler().exec(compilerMessageCollector, Services.EMPTY, jsArgs)
        )
    }

    /** Runs the compilation task */
    fun compile(): Result {
        // make sure all needed directories exist
        sourcesDir.mkdirs()
        classesDir.mkdirs()
        kaptSourceDir.mkdirs()
        kaptStubsDir.mkdirs()
        kaptIncrementalDataDir.mkdirs()
        kaptKotlinGeneratedDir.mkdirs()

        // write given sources to working directory
        val sourceFiles = sources.map { it.writeIfNeeded(sourcesDir) }


        compileKotlinJS(sourceFiles).let { exitCode ->
            if (exitCode != ExitCode.OK) {
                val messages = internalMessageBuffer.readUtf8()
                searchSystemOutForKnownErrors(messages)
                return Result(exitCode, classesDir, messages)
            }
            return Result(exitCode, classesDir, "OK")

        }


    }

    private fun commonClasspaths() = mutableListOf<File>().apply {
        addAll(classpaths)
        addAll(listOfNotNull(kotlinJsStdLibJar))

        if (inheritClassPath) {
            addAll(hostClasspaths)
            log("Inheriting classpaths:  " + hostClasspaths.joinToString(File.pathSeparator))
        }
    }.distinct()

    /** Searches compiler log for known errors that are hard to debug for the user */
    private fun searchSystemOutForKnownErrors(compilerSystemOut: String) {
        if (compilerSystemOut.contains("No enum constant com.sun.tools.javac.main.Option.BOOT_CLASS_PATH")) {
            warn(
                "${this::class.simpleName} has detected that the compiler output contains an error message that may be " +
                        "caused by including a tools.jar file together with a JDK of version 9 or later. " +
                        if (inheritClassPath)
                            "Make sure that no tools.jar (or unwanted JDK) is in the inherited classpath"
                        else ""
            )
        }

        if (compilerSystemOut.contains("Unable to find package java.")) {
            warn(
                "${this::class.simpleName} has detected that the compiler output contains an error message " +
                        "that may be caused by a missing JDK. This can happen if jdkHome=null and inheritClassPath=false."
            )
        }
    }

    /** Tries to find a file matching the given [regex] in the host process' classpath */
    private fun findInHostClasspath(hostClasspaths: List<File>, simpleName: String, regex: Regex): File? {
        val jarFile = hostClasspaths.firstOrNull { classpath ->
            classpath.name.matches(regex)
            //TODO("check that jar file actually contains the right classes")
        }

        if (jarFile == null)
            log("Searched host classpaths for $simpleName and found no match")
        else
            log("Searched host classpaths for $simpleName and found ${jarFile.path}")

        return jarFile
    }

    private val hostClasspaths by lazy { getHostClasspaths() }

    /* This internal buffer and stream is used so it can be easily converted to a string
    that is put into the [Result] object, in addition to printing immediately to the user's
    stream. */
    private val internalMessageBuffer = Buffer()
    private val internalMessageStream = PrintStream(
        TeeOutputStream(
            object : OutputStream() {
                override fun write(b: Int) = messageOutputStream.write(b)
                override fun write(b: ByteArray?) = messageOutputStream.write(b)
                override fun write(b: ByteArray?, off: Int, len: Int) = messageOutputStream.write(b, off, len)
                override fun flush() = messageOutputStream.flush()
                override fun close() = messageOutputStream.close()
            },
            internalMessageBuffer.outputStream()
        )
    )

    private fun log(s: String) {
        if (verbose)
            internalMessageStream.println("logging: $s")
    }

    private fun warn(s: String) = internalMessageStream.println("warning: $s")
    private fun error(s: String) = internalMessageStream.println("error: $s")

    companion object {
        const val OPTION_KAPT_KOTLIN_GENERATED = "kapt.kotlin.generated"
    }
}


/** Returns the files on the classloader's classpath and modulepath */
private fun getHostClasspaths(): List<File> {
    val classGraph = ClassGraph()
        .enableSystemJarsAndModules()
        .removeTemporaryFilesAfterScan()

    val classpaths = classGraph.classpathFiles
    val modules = classGraph.modules.mapNotNull { it.locationFile }

    return (classpaths + modules).distinctBy(File::getAbsolutePath)
}